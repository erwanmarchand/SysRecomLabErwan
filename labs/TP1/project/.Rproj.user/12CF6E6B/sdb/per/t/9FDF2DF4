{
    "collab_server" : "",
    "contents" : "---\ntitle: \"LOG6308 - Laboratoire 1 - Rapport\"\nauthor: \"Erwan Marchand - 1659273\"\ndate: \"September 10, 2017\"\noutput:\n  html_document:\n    df_print: kable\n    toc: yes\n  html_notebook: default\n  pdf_document:\n    df_print: kable\n    toc: yes\n---\n\n\\newpage\n\n# Presentation du laboratoire\n\nCe laboratoire a pour objectif de nous familiariser à l'estimation de votes d'utilisateurs par utilisation de filtre collaboratif mais également par une approche contenu. Afin de répondre aux questions de ce laboratoire, nous aurons à trouver par calcul les films les plus similaires à un film donné à l'aide de la mesure de cosinus ou de corrélation.\n\nLa remise de ce rapport contient 3 fichiers :\n\n- Le fichier .Rmd qui est une version finale du code crée à l'aide de Rmarkup, elle contient les commentaires et résultats.\n- Le fichier .pdf qui est le pdf généré via le fichier .Rmd.\n- Le fichier .html qui est le html généré via le fichier .Rmd.\n\nCes 3 fichiers contiennent donc exactement les memes données, seul le format change afin de laisser la liberté de choix pour la correction.\n\n# Création des données\n\n```{r}\nrm(list = ls())\n\nlibrary(Matrix)\n\nu.data <- read.csv(file='u.data.csv', sep='|', header=T)\nu.item <- read.csv(file='u.item.csv', sep='|', header=T)\nu.user <- read.csv(file='u.user.csv', sep='|', header=T)\n\nm.sparse <- sparseMatrix(u.data$user.id,u.data$item.id,x=u.data$rating)\nrownames(m.sparse) <- paste('u', 1:nrow(m.sparse), sep='')\ncolnames(m.sparse) <- paste('i', 1:ncol(m.sparse), sep='')\n\nm <- as.matrix(m.sparse)\n\nm[m==0] <- NA\n\n\nmx <- merge(u.user, u.data, 1)\n```\n\n# 1) Quelle est la moyenne des votes par profession (\"job\") et par âge?\n\n## Moyenne par profession\n\nLe code ci-dessous nous permet d'obtenir la liste des moyenne de classement par profession, afin d'alléger le rapport, nous n'en affichons que 6. De meme pour la liste des moyennes de classement par age.\n\n```{r}\nmeanPerJob <-aggregate(mx[, 7], list(mx$job), mean)\ncolnames(meanPerJob) <- c(\"job\",\"mean Rating\")\nhead(meanPerJob)\n```\n\n## Moyenne par age\n\n```{r}\nmeanPerAge <-aggregate(mx[, 7], list(mx$age), mean)\ncolnames(meanPerAge) <- c(\"age\",\"mean Rating\")\nhead(meanPerAge)\n```\n\n# 2) Quels sont les 10 films les plus similaires à \"Star Trek V: The Final Frontier (1989)\" selon respectivement la mesure du cosinus et de la corrélation avec la matrice de votes. \n\nAfin de répondre a cette question, il est necessaire de creer plusieurs fonctions.\n\n## Creation des fonctions\n\n### Cosinus entre un vecteur v et chaque colonne de la matrice m\n\n```{r}\ncosinus.vm <- function(v,m) { \n  n <- sqrt(colSums(m^2))\n  return ((v %*% m)/(n * sqrt(sum(v^2))))\n}\n```\n\n### Trouve les indexes des premieres 'n' valeurs maximales/minimales d'une matrice\n\n```{r}\nmax.nindex <- function(m, n=5) {\n  i <- order(m, decreasing=TRUE)\n  return(i[1:n])\n}\n\nmin.nindex <- function(m, n=5) {\n  i <- order(m)\n  return(i[1:n])\n}\n```\n\n## Les 10 films les plus similaires selon la mesure du cosinus avec la matrice de votes. \n\nSachant que le film le plus similaire a Star Trek V selon la matrice de vote sera toujours lui meme, il faut penser a le supprimer du resultat.\n\nDans un premier temps, on recupere l'indice du film considere ainsi que les notes qui y sont associes\n\n```{r tidy=TRUE}\nname.star.trek <- 'Star Trek V: The Final Frontier (1989)'\nindice.star.trek <- u.item[u.item$movie.title==name.star.trek,]$movie.id\nnotes.star.trek <- m.sparse[,indice.star.trek]\n```\n\nPuis on effectue les calculs pour la mesure du cosinus\n\n```{r tidy=TRUE}\nwcos <- cosinus.vm(notes.star.trek , m.sparse)\nsimilarMoviesCos.index <- max.nindex(wcos,11)\nsimilarMoviesCos.index <- similarMoviesCos.index[similarMoviesCos.index!=indice.star.trek ]\nsimilarMoviesCos.names <- u.item[similarMoviesCos.index,]$movie.title\nsimilarMoviesCos.names <- data.frame(similarMoviesCos.names)\ncolnames(similarMoviesCos.names) <- c(paste(\"Most similar movies from\",name.star.trek, sep = ' : '))\nsimilarMoviesCos.names\n```\n\n## Les 10 films les plus similaires selon la mesure de la correlation avec la matrice de votes. \n\n```{r tidy=TRUE}\nwcor <- as.vector(cor(notes.star.trek, as.matrix(m.sparse)))\nsimilarMoviesCor.index <- max.nindex(wcor,11)\nsimilarMoviesCor.index <- similarMoviesCor.index[similarMoviesCor.index!=indice.star.trek ]\nsimilarMoviesCor.names <- u.item[similarMoviesCor.index,]$movie.title\nsimilarMoviesCor.names <- data.frame(similarMoviesCor.names)\ncolnames(similarMoviesCor.names) <- c(paste(\"Most similar movies from\",name.star.trek, sep = ' : '))\nsimilarMoviesCor.names\n```\n\nOn peut constater qu'on obtient dans les 2 cas la meme liste de films.\n\n# 3) Utilisez une approche item-item pour calculer le vote au film \"Star Trek V: The Final Frontier (1989)\" des utilisateurs qui n'ont pas de vote pour celui-ci. Prenez les 20 voisins les plus rapprochés selon la distance euclidienne et utilisez les cosinus comme poids. Si aucun vote commun existe, alors la valeur prédite est fixée à NA.\n\n## Recuperation des 20 voisins les plus rapprochés selon la distance euclidienne du film \"Star Trek V\"\n\nIl est tout d'abord important de noter que nous devons considerer les 21 voisins les plus proches, sachant que le voisin le plus proche de Star Trek V sera toujours lui-meme tel que mentionne precedemment.\n\n```{r}\nn.voisins <- 20 + 1\n```\n\nOn peut ensuite recuperer le nombre de votes commun entre Star Trek V et chaque film, puis la distance euclidienne entre les votes de Star Trek et chaque film.\n\n```{r}\nvotes.communs <- (colSums((m.sparse[,indice.star.trek] * m.sparse) > 0))\ndistance.star.trek <- sqrt(colSums((m.sparse[,indice.star.trek] - m.sparse)^2))\ni.distance.star.trek <- min.nindex(distance.star.trek, n.voisins)\ni.distance.star.trek <- i.distance.star.trek[i.distance.star.trek!=indice.star.trek]\n```\n\n## Verifications des données récupérées\n\nOn peut maintenant verifier que la distance entre Star Trek et le meme est bien de 0.\n\n```{r}\ndistance.star.trek[indice.star.trek]\n```\n\nPuis on peut regarder le nombre de votes communs entre les 20 films les plus proches de Star Trek V et Star Trek V.\n\n```{r}\ntemp <- as.matrix(votes.communs[i.distance.star.trek])\ntemp <- data.frame(temp)\ncolnames(temp) <- c(\"nombre de votes communs\")\nrownames(temp) <- u.item[gsub('i','',rownames(temp)),]$movie.title\ntemp\n```\n\nOn peut s'appercevoir que par chance, aucun des 20 films les plus proche en distance euclidienne de Star Trek V n'a aucun vote en commun avec celui-ci.\n\n## Estimation des votes des utilisateurs n'ayant pas votés pour \"Star Trek V\"\n\nOn peut enfin effectuer les opérations nécessaires afin de calculer les votes des utilisateurs n'ayant pas votés pour le film \"Star Trek V\"\n\n```{r tidy=TRUE}\nwcos.voisin <- t(as.matrix(cosinus.vm(m.sparse[,indice.star.trek], m.sparse[,i.distance.star.trek])))\nm.sparse.star.trek.na <- as.matrix(m.sparse[which(is.na(m[,indice.star.trek])),i.distance.star.trek]) # on ne considere pas les utilisateurs ayant deja votés pour star trek\n\nm.star.trek.na <- as.matrix(m.sparse.star.trek.na)\nm.star.trek.na[m.star.trek.na==0] <- NA\n\nwcos.sums.star.trek.na <- m.star.trek.na\nwcos.sums.star.trek.na[!is.na(wcos.sums.star.trek.na)] <- 1\nwcos.sums.star.trek.na[is.na(wcos.sums.star.trek.na)] <- 0\nwcos.sums.star.trek.na <- abs(wcos.sums.star.trek.na %*% (as.matrix(wcos.voisin)))\nwcos.sums.star.trek.na[wcos.sums.star.trek.na==0] <- NA\n\nmean.star.trek = mean(m[,indice.star.trek], na.rm = TRUE)\n\nmeans.voisins.na = colMeans(m.star.trek.na, na.rm = TRUE) # moyenne pour chaque voisin sans vote des utilisateurs ayant votés pour star trek\nmeans.voisins.na[is.nan(means.voisins.na)] <- NA\n\ntemp <- t(t(m.star.trek.na)-means.voisins.na)\ntemp[is.na(temp)] <- 0\nnotes.star.trek.predicted.na <- temp%*%wcos.voisin/wcos.sums.star.trek.na\nnotes.star.trek.predicted.na[notes.star.trek.predicted.na == 0] <- NA\nnotes.star.trek.predicted.na <- mean.star.trek + notes.star.trek.predicted.na \n\nnotes.star.trek.predicted.na.no.na <- merge(rownames(notes.star.trek.predicted.na) [!is.na(notes.star.trek.predicted.na)], as.matrix(notes.star.trek.predicted.na[!is.na(as.matrix(notes.star.trek.predicted.na))]), by = \"row.names\")\n\ncolnames(notes.star.trek.predicted.na.no.na) <- c(\" \",\"Identifiant utilisateur\",\"vote prédit\")\nnotes.star.trek.predicted.na.no.na[1] <- NULL\nnotes.star.trek.predicted.na.no.na\n\n```\n\nOn peut constater que les résultats semblent cohérents car ils sont tous compris entre 0 et 5, de plus la moyenne de ces estimations est d'environ 2.39 ce qui est raisonnable.\n\n# 4) Calculez l'erreur quadratique moyenne des prédiction de l'approche item-item à la question précédente en la comparant aux valeurs observées. \n\n\nDans un premier temps, on doit recalculer les vote estimés, cette fois-ci pour les utilisateurs ayant deja votés.\n\n## Calcul des votes estimés pour les utilisateurs ayant déjà votés.\n\n```{r tidy=TRUE}\nm.sparse.star.trek <- as.matrix(m.sparse[which(!is.na(m[,indice.star.trek])),i.distance.star.trek]) # on ne considere que les utilisateurs ayant deja votés pour star trek\n\nm.star.trek <- as.matrix(m.sparse.star.trek)\nm.star.trek[m.star.trek==0] <- NA\n\nwcos.sums.star.trek <- m.star.trek\nwcos.sums.star.trek[!is.na(wcos.sums.star.trek)] <- 1\nwcos.sums.star.trek[is.na(wcos.sums.star.trek)] <- 0\nwcos.sums.star.trek <- abs(wcos.sums.star.trek %*% (as.matrix(wcos.voisin)))\nwcos.sums.star.trek[wcos.sums.star.trek==0] <- NA\n\nmeans.voisins = colMeans(m.star.trek, na.rm = TRUE) # moyenne pour chaque voisin avec vote des utilisateurs ayant votés pour star trek\nmeans.voisins[is.nan(means.voisins)] <- NA\n\ntemp <- t(t(m.star.trek)-means.voisins)\ntemp[is.na(temp)] <- 0\nnotes.star.trek.predicted <- temp%*%wcos.voisin/wcos.sums.star.trek \nnotes.star.trek.predicted[notes.star.trek.predicted == 0] <- NA\nnotes.star.trek.predicted <- mean.star.trek + notes.star.trek.predicted \n```\n\nOn peut ensuite afficher les votes calculés par rapport aux votes réels.\n\n## Comparaison des votes estimés aux votes réels.\n\n```{r tidy=TRUE}\nnotes.star.trek.predicted.no.na <- merge(as.matrix(notes.star.trek.predicted),as.matrix(notes.star.trek), by = \"row.names\")\ncolnames(notes.star.trek.predicted.no.na) <- c(\"Identifiant utilisateur\",\"vote prédit\",\"vote réel\")\nnotes.star.trek.predicted.no.na <- na.omit(notes.star.trek.predicted.no.na)\nrownames(notes.star.trek.predicted.no.na) <- NULL\nnotes.star.trek.predicted.no.na\n```\n\nOn peut constater que les votes estimés sont souvent proches des votes réels malgre parfois un ecart de 1 voir 2 points.\n\n## Calcul de l'erreur quadratique moyenne.\n\n```{r tidy=TRUE}\nerreur.quadratique <- sqrt(mean((notes.star.trek.predicted.no.na[,\"vote prédit\"] - notes.star.trek.predicted.no.na[,\"vote réel\"])^2, na.rm=TRUE))\nerreur.quadratique\n```\n\nOn peut constater que l'erreur quadratique de nos estimations est d'environ 0.86, ce qui est explicable par le faible nombre de votes communs parfois utilisé afin de générer ces estimations.\n\n# 5) Un utilisateur a coté la note la plus faible (1) à tous les films de Star Wars et la note la plus forte (5) à tous les films de Star Trek. Quels 10 films lui conseillez-vous? Utilisez une approche utilisateur-utilisateur pour la réponse et 20 voisins rapprochés.\n\nPour répondre à cette question, on peut obter pour une approche similaire à celle de la question 3.\n\n## Initialisation du vecteur de votes du nouvel utilisateur.\n\n```{r tidy=TRUE}\nindices.star.trek <- grep(\"trek\", as.character(u.item$movie.title), ignore.case=TRUE)\nindices.star.wars <- c(172,181)\n\nvotes.new.user <- user.votes <- rep(0, ncol(m.sparse))\nvotes.new.user[indices.star.trek] <- 5\nvotes.new.user[indices.star.wars] <- 1\n```\n\n## Recuperation des 20 voisins les plus rapprochés selon la distance euclidienne du nouvel utilisateur.\n\n```{r tidy=TRUE}\nvotes.communs.new.user <- (rowSums((votes.new.user * m.sparse) > 0))\ndistance.new.user <- sqrt(rowSums((votes.new.user - m.sparse)^2))\ni.distance.new.user <- min.nindex(distance.new.user, 20) #pas besoin de supprimer notre utilisateur de cette liste car il n'apparait pas dans m.sparse\n```\n\n## Estimation des notes du nouvel utilisateur pour les films qu'il n'a pas vu.\n\n```{r tidy=TRUE}\nwcos.new.user.voisins <- as.vector(cosinus.vm(votes.new.user, t(m.sparse[i.distance.new.user,])))\n\nm.sparse.new.user <- as.matrix(m.sparse[i.distance.new.user,])\n\nm.new.user <- as.matrix(m.sparse.new.user)\nm.new.user[m.new.user==0] <- NA\n\nwcos.sums.new.user <- m.new.user\nwcos.sums.new.user[!is.na(wcos.sums.new.user)] <- 1\nwcos.sums.new.user[is.na(wcos.sums.new.user)] <- 0\nwcos.sums.new.user <- abs(t(wcos.sums.new.user) %*% (as.matrix(wcos.new.user.voisins)))\nwcos.sums.new.user[wcos.sums.new.user==0] <- NA\n\nmean.new.user = mean(votes.new.user[votes.new.user>0], na.rm = TRUE)\n\nmeans.voisins.new.user = rowMeans(m.new.user, na.rm = TRUE) # moyenne pour chaque voisin\nmeans.voisins.new.user[is.nan(means.voisins.new.user)] <- NA\n\ntemp <- t(t(m.new.user)-means.voisins)\ntemp[is.na(temp)] <- 0\n\nnotes.new.user.predicted <- t(temp)%*%wcos.new.user.voisins/wcos.sums.new.user\nnotes.new.user.predicted[notes.new.user.predicted == 0] <- NA\nnotes.new.user.predicted <- mean.new.user + notes.new.user.predicted\n```\n\n## Affichage des 10 films auquels l'utilisateur est susceptible de donner les meilleurs notes.\n\n```{r tidy=TRUE}\nindices.movies.recommended.new.user <- min.nindex(distance.new.user, 10)\ntitle.movies.recommended.new.user <- as.matrix(u.item$movie.title[indices.movies.recommended.new.user])\ntitle.movies.recommended.new.user <- data.frame(title.movies.recommended.new.user)\ncolnames(title.movies.recommended.new.user) <- c(\"Recommended movies\")\ntitle.movies.recommended.new.user\n```\n\n# 6) Je suis un nouvel utilisateur. Vous connaissez ma profession, mon sexe et mon âge. Développez un algorithme bayésien pour recommander 10 films sur la base de ces trois catégories.\n\nAfin de répondre à cette question, il est nécessaire de \"discretiser\" la variable pour l'age de l'utilisateur, sans quoi les nombre de comparaisons avec d'autres utilisateurs du meme age sera trop faible. A cette fin, l'approche vue en cours sera utilisée : les ages seront séparés en 2 groupes : les moins de 50 ans et les 50 ans et plus. Cette approche peut sembler diminuer fortement la precision de l'algorithme, cependant les 2 autres precision (sexe et profession) permettront d'obtenir des resultats suffisament precis pour globaliser fortement l'age du nouvel utilisateur.",
    "created" : 1504983923495.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "0|3|12|0|\n16|29|27|0|\n329|184|331|580|\n",
    "hash" : "1680285564",
    "id" : "9FDF2DF4",
    "lastKnownWriteTime" : 1505475734,
    "last_content_update" : 1505475734197,
    "path" : "C:/Users/erwan/Desktop/boulot/DESS/session 1/LOG6308/labs/TP1/project/Rapport.Rmd",
    "project_path" : "Rapport.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "docOutlineVisible" : "0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}